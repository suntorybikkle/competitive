# abc171

- 4完だった
- 満足のいく結果ではあるが、残りの問題に手も足も出なかった

# A

- golangは`x**2`みたいな書き方ができない

# B

- 2つも文字列中の異なる箇所を数えるだけ

# C

- C問題の中では難しく感じた
- 累積和を使えば、何冊で何本かをすぐに計算可能
- 制約的に、全探策はできないため、累積和がソート済みということを利用して２部探索すれば解答できる
- ただし模範解答は以下で、計算量も小さい
  - 片方の値を固定したとき、和が`K`以下で最大となる値は一意に定まる
  - 累積和であれば両社ともソート済みなので、一方の値を大きくしたら、もう一方の値はその前の時点と同じが、それより小さい要素であることが確実である
  - 上記を利用して、一方を0から選び、もう一方を最大から順に`K`以下を満たす最大の数値を選ぶ
  - 以降繰り返せば、両社とも１巡しかしないため、計算量 N + M

# D

- エラトステネスの篩のようなアルゴリズムで解ける
- ある値の約数の個数は、それより小さい数全ての倍数を確認することでもわかる
- 上記を確認すれば、副次的にある値より小さい数の約数の個数もすべてわかる
- 計算量は N * log N

# E

- 現時点では知識が大きく足りず、解説を見てもかなり難しかった
- 条件が2つあり、X: A_i != B_i, Y: 数列中のすべての値は異なる、とする
- 想定する考えのプロセス
  - 条件を一方だけであれば、容易に答えを計算可能
  - Yの条件を満たしたAを仮定し、BをX, Yの条件を満たす場合の数を考えると難しく感じるはず
    - Aを固定した場合、Bの一つ目はM-1通り
    - Bの2つ目はBの一つ目で、Aの2つ目にあたる数字を使ったか使ってないかで変わってしまう (使用済み M-1, 未使用 M-2)
    - 上記までの時点で、包除原理じゃないかと伺えるようになりたい
  - 包除原理とあたりがつけば、A_i == B_iとなる個数別の場合の数を考えることとなる
    - とりあえずiの個数を決める sとする
    - sの箇所はnCs通り
    - sに含まれる数列の選び方は順番も考慮する必要があるためmPs
    - 残りのA, Bともに、m-sPn-s (この時、かぶる数字はS以上という点に注意)
  - 包除原理と上記を利用して -1**k * nCk * mPk * m-kPn-k * m-kPn-k をk=0からk=Nまで繰り返す

## 1e9+7周りの計算

```go
const MOD = 1e9+7

var fact [5e5 + 1]int
var finv [5e5 + 1]int
var inv [5e5 + 1]int

func comb(n, k int) int {
     return fact[n] * (finv[k] * finv[n-k] % MOD) % MOD
}

func perm(n, k int) int {
     return fact[n] * (finv[n-k] % MOD) % MOD
}

func main() {
     fact[0], fact[1] = 1, 1
     finv[0], finv[1] = 1, 1
     inv[1] = 1
     for i := 2; i < m+1; i++ {
         fact[i] = i * fact[i-1] % MOD
	 inv[i] = MOD - inv[MOD%i]*(MOD/i)%MOD
	 finv[i] = finv[i-1] * inv[i] % MOD
     }
     comb(x, y)
}
```
